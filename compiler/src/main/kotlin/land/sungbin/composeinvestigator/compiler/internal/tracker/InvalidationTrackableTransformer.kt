/*
 * Designed and developed by Ji Sungbin 2023.
 *
 * Licensed under the MIT.
 * Please see full license: https://github.com/jisungbin/ComposeInvestigator/blob/main/LICENSE
 */

package land.sungbin.composeinvestigator.compiler.internal.tracker

import androidx.compose.compiler.plugins.kotlin.analysis.StabilityInferencer
import androidx.compose.compiler.plugins.kotlin.analysis.normalize
import land.sungbin.composeinvestigator.compiler.internal.irString
import land.sungbin.composeinvestigator.compiler.internal.irTracee
import land.sungbin.composeinvestigator.compiler.internal.logger.InvestigateLogger
import land.sungbin.composeinvestigator.compiler.internal.origin.InvalidationTrackerOrigin
import land.sungbin.composeinvestigator.compiler.internal.stability.toIrDeclarationStability
import land.sungbin.composeinvestigator.compiler.internal.tracker.key.DurableWritableSlices
import land.sungbin.composeinvestigator.compiler.util.VerboseLogger
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.declarations.IrAttributeContainer
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.expressions.IrBlock
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.addElement
import org.jetbrains.kotlin.ir.expressions.impl.IrBlockImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrVarargImpl
import org.jetbrains.kotlin.ir.types.defaultType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.types.typeWithArguments
import org.jetbrains.kotlin.ir.util.dump
import org.jetbrains.kotlin.ir.util.dumpKotlinLike
import org.jetbrains.kotlin.types.Variance

internal class InvalidationTrackableTransformer(
  private val context: IrPluginContext,
  private val logger: VerboseLogger,
  private val stabilityInferencer: StabilityInferencer,
) : AbstractInvalidationTrackingLower(context, logger), IrPluginContext by context {
  override fun visitComposableIrBlock(function: IrFunction, expression: IrBlock): IrBlock {
    val newStatements = mutableListOf<IrStatement>()

    val currentFunctionName = function.name.asString()
    val currentFunctionLocation = function.getSafelyLocation()
    val currentInvalidationTrackTable = currentInvalidationTrackTable!!

    val paramInfoType = currentInvalidationTrackTable.paramInfoSymbol.defaultType
    val paramInfoGenericTypeProjection = makeTypeProjection(type = paramInfoType, variance = Variance.OUT_VARIANCE)
    val paramInfoGenericType = irBuiltIns.arrayClass.typeWithArguments(listOf(paramInfoGenericTypeProjection))
    val paramInfos = IrVarargImpl(
      startOffset = UNDEFINED_OFFSET,
      endOffset = UNDEFINED_OFFSET,
      type = paramInfoGenericType,
      varargElementType = paramInfoType,
    )

    // The last two arguments are generated by the Compose compiler ($composer, $changed)
    val validValueParamters = function.valueParameters.dropLast(2)
    for (param in validValueParamters) {
      fun nameHint(fieldName: String) = "${param.name.asString()}\$$fieldName"
      val name = irTmpVariableInCurrentFun(irString(param.name.asString()), nameHint = nameHint("name"))
      val valueGetter = irGetValue(param)
      val valueString = irTmpVariableInCurrentFun(irToString(valueGetter), nameHint = nameHint("value#toString"))
      val hashCode = irTmpVariableInCurrentFun(irHashCode(valueGetter), nameHint = nameHint("value#hashCode"))
      val stability = irTmpVariableInCurrentFun(
        stabilityInferencer.stabilityOf(valueGetter).normalize().toIrDeclarationStability(context),
        nameHint = nameHint("value#stability"),
      )

      newStatements += listOf(name, valueString, hashCode, stability)
      paramInfos.addElement(
        currentInvalidationTrackTable.obtainParameterInfo(
          name = name,
          valueString = valueString,
          valueHashCode = hashCode,
          stability = stability,
        ),
      )
    }

    val currentFunctionKeyName = irTracee[DurableWritableSlices.DURABLE_FUNCTION_KEY, function as IrAttributeContainer]!!.name
    val computeDiffParamsIfPresent =
      currentInvalidationTrackTable.irComputeDiffParamsIfPresent(
        keyName = irString(currentFunctionKeyName),
        originalName = irString(currentFunctionName),
        paramInfos = paramInfos,
      )
    val computeDiffParamsIfPresentVariable = irTmpVariableInCurrentFun(
      computeDiffParamsIfPresent,
      nameHint = "$currentFunctionName\$diffParams",
    )
    newStatements += computeDiffParamsIfPresentVariable

    val originalLogMessage = irString("[INVALIDATION_TRACKER] <${getCurrentFunctionNameIntercepttedAnonymous()}> invalidation processed")
    val affectedComposable = InvestigateLogger.irAffectedComposable(
      context = context,
      functionName = currentFunctionName,
      packageName = getCurrentFunctionPackage(),
      location = currentFunctionLocation,
    )
    val invalidateTypeSymbol = InvestigateLogger.irInvalidateTypeSymbol(context)
    val invalidateTypeProcessed = InvestigateLogger.irInvalidateTypeProcessed(
      context = context,
      diffParams = irGetValue(computeDiffParamsIfPresentVariable),
    ).apply { type = invalidateTypeSymbol.defaultType }

    val logger = InvestigateLogger.irLog(
      affectedComposable = affectedComposable,
      invalidateType = invalidateTypeProcessed,
      originalMessage = originalLogMessage,
    )
    newStatements += logger

    expression.statements.addAll(1, newStatements)
    expression.origin = InvalidationTrackerOrigin

    val log = buildString {
      for ((index, statement) in expression.statements.withIndex()) {
        val dump = run {
          val dump = statement.dump().trimIndent()
          if (dump.length > 500) dump.substring(0, 500) + "..." else dump
        }
        if (index == 1) appendLine(">>>>>>>>>> ADD: ${logger.dump()}")
        appendLine(dump)
        if (index == 3) {
          appendLine("...")
          break
        }
      }
    }

    logger("[invalidation processed] $log")
    logger("[invalidation processed] dump: ${expression.dump()}")
    logger("[invalidation processed] dumpKotlinLike: ${expression.dumpKotlinLike()}")

    return expression
  }

  override fun visitSkipToGroupEndCall(function: IrFunction, expression: IrCall): IrBlock {
    val currentFunctionLocation = function.getSafelyLocation()
    val currentFunctionName = function.name.asString()

    val originalLogMessage = irString("[INVALIDATION_TRACKER] <${getCurrentFunctionNameIntercepttedAnonymous()}> invalidation skipped")
    val affectedComposable = InvestigateLogger.irAffectedComposable(
      context = context,
      functionName = currentFunctionName,
      packageName = getCurrentFunctionPackage(),
      location = currentFunctionLocation,
    )
    val invalidateTypeSymbol = InvestigateLogger.irInvalidateTypeSymbol(context)
    val invalidateTypeSkipped = InvestigateLogger.irInvalidateTypeSkipped(context)
      .apply { type = invalidateTypeSymbol.defaultType }

    val logger = InvestigateLogger.irLog(
      affectedComposable = affectedComposable,
      invalidateType = invalidateTypeSkipped,
      originalMessage = originalLogMessage,
    )
    val block = IrBlockImpl(
      startOffset = UNDEFINED_OFFSET,
      endOffset = UNDEFINED_OFFSET,
      type = irBuiltIns.unitType,
      origin = InvalidationTrackerOrigin,
      statements = listOf(logger, expression),
    )

    logger("[invalidation skipped] transformed: ${expression.dumpKotlinLike()} -> ${block.dumpKotlinLike()}")

    return block
  }
}
